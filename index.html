<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>MML Composer (No-Regex, Extensible)</title>
    <style>
      body { font-family: system-ui, sans-serif; margin: 20px; }
      textarea { width: 100%; height: 180px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      .row { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
      button { padding: 8px 12px; }
      select, input[type="number"] { padding: 6px; }
      .small { font-size: 12px; color: #555; }
      .tracks { white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f6f8fa; padding: 8px; border-radius: 6px; }
    </style>
  </head>
  <body>
    <h1>MML Composer</h1>
    <p class="small">
      

      各行が独立したトラックとして同時に再生されます。例は下にあります。
    </p>
    <textarea id="mml"></textarea>
    <div class="row">
      <button id="play">Play</button>
      <button id="stop">Stop</button>
      <button id="wav">Wav</button>
      <label
        >Master volume
        <input id="master" type="range" min="0" max="1" step="0.01" value="0.9"
      /></label>
    </div>
    <div class="small tracks" id="help">
      Supported: - Notes A-G with + - #, rests r - oN octave, < > step, tBPM, lN
      default length (1,2,4,8,16,...) - v0..127 volume, p-64..64 pan,
      @instrument - dotted ., tie &, loops [ ... ]n
    </div>
    <script>
      // ----------------------------
      // Utility: frequency from pitch
      // ----------------------------
      function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }
      const NOTE_BASE = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 };

      // ----------------------------
      // Tokenizer (no regex)
      // ----------------------------
      class Reader {
        constructor(text) {
          this.text = text;
          this.i = 0;
        }
        peek() {
          return this.text[this.i] ?? null;
        }
        next() {
          return this.text[this.i++] ?? null;
        }
        eof() {
          return this.i >= this.text.length;
        }
        skipSpaces() {
          while (!this.eof()) {
            const c = this.peek();
            if (c === " " || c === "\t" || c === "\r") this.next();
            else break;
          }
        }
        readInt() {
          let s = "";
          while (!this.eof()) {
            const c = this.peek();
            if (c >= "0" && c <= "9") {
              s += c;
              this.next();
            } else break;
          }
          return s.length ? parseInt(s, 10) : null;
        }
        readIdent() {
          let s = "";
          while (!this.eof()) {
            const c = this.peek();
            if (
              (c >= "a" && c <= "z") ||
              (c >= "A" && c <= "Z") ||
              c === "_" ||
              c === "-"
            ) {
              s += c;
              this.next();
            } else break;
          }
          return s.toLowerCase();
        }
      }

      // ----------------------------
      // Parser: to AST events per track
      // ----------------------------
      function parseTrack(mmlText) {
        const r = new Reader(mmlText);
        const events = [];
        let state = {
          tempo: 120,
          octave: 4,
          defaultLen: 4, // quarter
          volume: 100, // 0..127
          pan: 0, // -64..64
          instrument: "square",
        };

        function readAccidental(r) {
          let acc = 0;
          const c = r.peek();
          if (c === "+" || c === "#") {
            acc = 1;
            r.next();
          } else if (c === "-") {
            acc = -1;
            r.next();
          }
          return acc;
        }

        function readDots(r) {
          let dots = 0;
          while (r.peek() === ".") {
            r.next();
            dots++;
          }
          return dots;
        }

        function pushCommand(type, value) {
          events.push({ type, value });
        }

        function pushNoteOrRest(kind, note, acc, len, dots, tie) {
          events.push({ type: kind, note, acc, len, dots, tie });
        }

        function parseLoop(r) {
          // [ ... ]n
          const body = [];
          if (r.next() !== "[") return;
          let depth = 1;
          const start = r.i;
          // Collect raw inside
          let raw = "";
          while (!r.eof() && depth > 0) {
            const c = r.next();
            if (c === "[") depth++;
            else if (c === "]") depth--;
            if (depth > 0) raw += c;
          }
          const times = r.readInt() ?? 2;
          body.push({ type: "loop", raw, times });
          events.push(...body);
        }

        while (!r.eof()) {
          r.skipSpaces();
          const c = r.peek();
          if (c === null) break;
          // Comments: ; to end of line
          if (c === ";") {
            while (!r.eof() && r.next() !== "\n") {}
            continue;
          }
          // Newline -> treat as separator; but track-level only here
          if (c === "\n") {
            r.next();
            continue;
          }

          if (c === "t" || c === "T") {
            r.next();
            const bpm = r.readInt();
            if (bpm !== null) {
              state.tempo = Math.max(1, bpm);
              pushCommand("tempo", state.tempo);
            }
            continue;
          }
          if (c === "o" || c === "O") {
            r.next();
            const o = r.readInt();
            if (o !== null) {
              state.octave = Math.max(0, Math.min(8, o));
              pushCommand("octave", state.octave);
            }
            continue;
          }
          if (c === "l" || c === "L") {
            r.next();
            const dl = r.readInt();
            if (dl !== null) {
              state.defaultLen = dl;
              pushCommand("defaultLen", state.defaultLen);
            }
            continue;
          }
          if (c === "v" || c === "V") {
            r.next();
            const v = r.readInt();
            if (v !== null) {
              state.volume = Math.max(0, Math.min(127, v));
              pushCommand("volume", state.volume);
            }
            continue;
          }
          if (c === "p" || c === "P") {
            r.next();
            const p = r.readInt();
            if (p !== null) {
              state.pan = Math.max(-64, Math.min(64, p));
              pushCommand("pan", state.pan);
            }
            continue;
          }
          if (c === "@") {
            r.next();
            const name = r.readIdent();
            if (name) {
              state.instrument = name;
              pushCommand("instrument", name);
            }
            continue;
          }
          if (c === "<" || c === ">") {
            r.next();
            if (c === "<") {
              state.octave = Math.max(0, state.octave - 1);
              pushCommand("octave", state.octave);
            } else {
              state.octave = Math.min(8, state.octave + 1);
              pushCommand("octave", state.octave);
            }
            continue;
          }
          if (c === "[") {
            parseLoop(r);
            continue;
          }

          // Note or rest
          if (/[abcdefgABCDEFGrR]/.test(c)) {
            const ch = r.next().toLowerCase();
            if (ch === "r") {
              const len = r.readInt();
              const dots = readDots(r);
              let tie = false;
              if (r.peek() === "&") {
                r.next();
                tie = true;
              }
              pushNoteOrRest("rest", null, 0, len, dots, tie);
            } else {
              const base = NOTE_BASE[ch];
              const acc = readAccidental(r);
              const len = r.readInt();
              const dots = readDots(r);
              let tie = false;
              if (r.peek() === "&") {
                r.next();
                tie = true;
              }
              pushNoteOrRest("note", base, acc, len, dots, tie);
            }
            continue;
          }

          // Unknown char -> skip
          r.next();
        }

        return { events, initial: state };
      }

      // ----------------------------
      // Sequencer: events to timeline
      // ----------------------------
      function dottedFactor(dots) {
        // geometric sum: 1 + 1/2 + 1/4 + ...
        let f = 1,
          add = 0.5;
        for (let i = 0; i < dots; i++) {
          f += add;
          add /= 2;
        }
        return f;
      }
      function lengthToBeats(denom) {
        // defaultLen is denominator: 1=whole, 2=half, 4=quarter, etc.
        return 4 / (denom || 4); // quarter=1 beat, whole=4 beats
      }

      function buildTimeline(ast) {
        const { events, initial } = ast;
        let tempo = initial.tempo;
        let octave = initial.octave;
        let defLen = initial.defaultLen;
        let volume = initial.volume;
        let pan = initial.pan;
        let instrument = initial.instrument;

        const timeline = [];
        let timeBeats = 0;

        function pushNote(pitchMidi, beats, vol, pan, inst) {
          timeline.push({
            type: "note",
            startBeats: timeBeats,
            beats,
            pitchMidi,
            volume: vol,
            pan,
            instrument: inst,
          });
          timeBeats += beats;
        }
        function pushRest(beats) {
          timeline.push({ type: "rest", startBeats: timeBeats, beats });
          timeBeats += beats;
        }

        // Expand possibly nested loops by recursive parse of raw
        function expandRaw(raw, times) {
          for (let i = 0; i < times; i++) {
            const sub = parseTrack(raw);
            // Recursively evaluate sub events with current state (tempo etc remain)
            sub.events.forEach((ev) => {
              if (ev.type === "tempo") tempo = ev.value;
              else if (ev.type === "octave") octave = ev.value;
              else if (ev.type === "defaultLen") defLen = ev.value;
              else if (ev.type === "volume") volume = ev.value;
              else if (ev.type === "pan") pan = ev.value;
              else if (ev.type === "instrument") instrument = ev.value;
              else if (ev.type === "note") {
                const denom = ev.len || defLen;
                const beats = lengthToBeats(denom) * dottedFactor(ev.dots || 0);
                const midi = octave * 12 + ev.note + ev.acc;
                // tie: accumulate next durations of same pitch/rest
                if (ev.tie) {
                  let accumBeats = beats;
                  // peek ahead in the sub.events only? Simpler: just immediate next in original raw not available.
                  // For practicality, we support ties only across contiguous items in same pass; re-parse raw resolves that.
                  // Users can chain ties inside raw loop too.
                  pushNote(midi, accumBeats, volume, pan, instrument);
                } else {
                  pushNote(midi, beats, volume, pan, instrument);
                }
              } else if (ev.type === "rest") {
                const denom = ev.len || defLen;
                const beats = lengthToBeats(denom) * dottedFactor(ev.dots || 0);
                pushRest(beats);
              } else if (ev.type === "loop") {
                expandRaw(ev.raw, ev.times);
              }
            });
          }
        }

        // Main pass
        events.forEach((ev) => {
          if (ev.type === "tempo") tempo = ev.value;
          else if (ev.type === "octave") octave = ev.value;
          else if (ev.type === "defaultLen") defLen = ev.value;
          else if (ev.type === "volume") volume = ev.value;
          else if (ev.type === "pan") pan = ev.value;
          else if (ev.type === "instrument") instrument = ev.value;
          else if (ev.type === "note") {
            const denom = ev.len || defLen;
            const beats = lengthToBeats(denom) * dottedFactor(ev.dots || 0);
            const midi = octave * 12 + ev.note + ev.acc;
            pushNote(midi, beats, volume, pan, instrument);
          } else if (ev.type === "rest") {
            const denom = ev.len || defLen;
            const beats = lengthToBeats(denom) * dottedFactor(ev.dots || 0);
            pushRest(beats);
          } else if (ev.type === "loop") {
            expandRaw(ev.raw, ev.times);
          }
        });

        const secondsPerBeat = 60 / tempo;
        // Convert beats to seconds
        return timeline.map((ev) => ({
          ...ev,
          startSec: ev.startBeats * secondsPerBeat,
          durSec: ev.beats * secondsPerBeat,
        }));
      }

      // ----------------------------
      // Instrument system (Web Audio)
      // ----------------------------
      class Engine {
        constructor() {
          this.ctx = null;
          this.master = null;
          this.panner = null;
          this.instruments = new Map();
          this.voices = new Set();
          this._startedAt = 0;
        }
        ensure() {
          if (!this.ctx) {
            const ctx = new (window.AudioContext ||
              window.webkitAudioContext)();
            this.ctx = ctx;
            this.master = ctx.createGain();
            this.master.gain.value = parseFloat(
              document.getElementById("master").value
            );
            this.master.connect(ctx.destination);
          }
        }
        setMaster(vol) {
          if (this.master)
            this.master.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.01);
        }
        registerInstrument(name, factory) {
          this.instruments.set(name, factory);
        }
        createVoice(name, options) {
          const factory = this.instruments.get(name);
          if (!factory) throw new Error("Unknown instrument: " + name);
          return factory(this.ctx, options);
        }
        stopAll() {
          const now = this.ctx ? this.ctx.currentTime : 0;
          for (const v of this.voices) {
            try {
              v.stop(now);
            } catch {}
          }
          this.voices.clear();
        }
        play(tracks) {
          this.ensure();
          this.stopAll();
          const startAt = this.ctx.currentTime + 0.05;
          this._startedAt = startAt;
          for (const tl of tracks) {
            for (const ev of tl) {
              if (ev.type === "note") {
                const v = this.createVoice(ev.instrument, {
                  gain: ev.volume / 127,
                  pan: ev.pan / 64,
                });
                const t0 = startAt + ev.startSec;
                const t1 = t0 + ev.durSec;
                v.start(t0, midiToFreq(ev.pitchMidi), ev.durSec);
                v.stop(t1);
                this.voices.add(v);
              }
            }
          }
        }
      }

      // ----------------------------
      // Built-in instruments
      // ----------------------------
      function adsr(
        gainNode,
        ctx,
        t0,
        dur,
        a = 0.01,
        d = 0.08,
        s = 0.6,
        r = 0.08,
        peak = 1.0
      ) {
        const g = gainNode.gain;
        const tA = t0 + a;
        const tD = tA + d;
        const tS = t0 + Math.max(0, dur - r);
        const tR = tS + r;
        g.cancelScheduledValues(t0);
        g.setValueAtTime(0.0001, t0);
        g.linearRampToValueAtTime(peak, tA);
        g.linearRampToValueAtTime(peak * s, tD);
        g.setValueAtTime(peak * s, tS);
        g.linearRampToValueAtTime(0.0001, tR);
      }

      function makePanner(ctx, pan) {
        const panNode = new StereoPannerNode(ctx, { pan: pan || 0 });
        return panNode;
      }

      // Square/Saw/Noise/FM like simple instruments
      function OscInstrument(
        ctx,
        {
          type = "square",
          gain = 0.8,
          pan = 0,
          a = 0.01,
          d = 0.06,
          s = 0.7,
          r = 0.06,
        }
      ) {
        const osc = ctx.createOscillator();
        osc.type = type;
        const outGain = ctx.createGain();
        const panNode = makePanner(ctx, pan);
        osc.connect(outGain);
        outGain.connect(panNode).connect(engine.master);
        return {
          start(t, freq, dur) {
            osc.frequency.setValueAtTime(freq, t);
            adsr(outGain, ctx, t, dur, a, d, s, r, gain);
            osc.start(t);
          },
          stop(t) {
            try {
              osc.stop(t + 0.001);
            } catch {}
          },
        };
      }

      function NoiseInstrument(
        ctx,
        { gain = 0.4, pan = 0, a = 0.001, d = 0.02, s = 0.3, r = 0.05 }
      ) {
        const bufferSize = 2 * ctx.sampleRate;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const src = ctx.createBufferSource();
        src.buffer = buffer;
        src.loop = true;
        const outGain = ctx.createGain();
        const panNode = makePanner(ctx, pan);
        src.connect(outGain);
        outGain.connect(panNode).connect(engine.master);
        return {
          start(t, freqIgnored, dur) {
            adsr(outGain, ctx, t, dur, a, d, s, r, gain);
            src.start(t);
          },
          stop(t) {
            try {
              src.stop(t + 0.001);
            } catch {}
          },
        };
      }
      // Duty付きPulseのPeriodicWave生成（NES/PSG系）
function createPulseWave(ctx, duty=0.5, harmonics=64) {
  // Fourier係数から擬似パルスを合成
  const real = new Float32Array(harmonics);
  const imag = new Float32Array(harmonics);
  // パルス波は奇偶両方の高調波を持つが、dutyで重みが変化
  for (let n = 1; n < harmonics; n++) {
    const a = Math.sin(Math.PI * n * duty) / (Math.PI * n);
    // sawの係数に矩形変換：cos/sinの分配
    real[n] = 0;        // 実部を0、虚部に成分を持たせる（位相90°）
    imag[n] = 2 * a;    // 幅dutyの矩形のフーリエ係数
  }
  return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
}

// 32サンプル程度の波形配列からPeriodicWave（Namco/FDS風）
function createWavetable(ctx, table) {
  const N = 64; // 倍音数（解析側）
  const real = new Float32Array(N);
  const imag = new Float32Array(N);
  // 簡略: tableをそのまま周期関数とみなしDFT
  const L = table.length;
  for (let k = 1; k < N; k++) {
    let re = 0, im = 0;
    for (let n = 0; n < L; n++) {
      const x = table[n];
      const phase = 2 * Math.PI * k * n / L;
      re += x * Math.cos(phase);
      im += x * Math.sin(phase);
    }
    real[k] = re / L;
    imag[k] = im / L;
  }
  return ctx.createPeriodicWave(real, imag, { disableNormalization: false });
}

// ADSRユーティリティ
function scheduleADSR(g, t, dur, {a=0.01, d=0.08, s=0.6, r=0.08, peak=1.0}) {
  const tA = t + a, tD = tA + d, tS = Math.max(t + dur - r, tA);
  const tR = tS + r;
  g.cancelScheduledValues(t);
  g.setValueAtTime(0.0001, t);
  g.linearRampToValueAtTime(peak, tA);
  g.linearRampToValueAtTime(peak * s, tD);
  g.setValueAtTime(peak * s, tS);
  g.linearRampToValueAtTime(0.0001, tR);
  return { stopAt: tR };
}

      function FMInstrument(
        ctx,
        {
          gain = 0.7,
          pan = 0,
          a = 0.01,
          d = 0.05,
          s = 0.6,
          r = 0.08,
          ratio = 2,
          index = 50,
        }
      ) {
        const carrier = ctx.createOscillator();
        const mod = ctx.createOscillator();
        const modGain = ctx.createGain();
        carrier.type = "sine";
        mod.type = "sine";
        mod.connect(modGain);
        modGain.connect(carrier.frequency);
        const outGain = ctx.createGain();
        const panNode = makePanner(ctx, pan);
        carrier.connect(outGain);
        outGain.connect(panNode).connect(engine.master);
        return {
          start(t, freq, dur) {
            carrier.frequency.setValueAtTime(freq, t);
            mod.frequency.setValueAtTime(freq * ratio, t);
            modGain.gain.setValueAtTime(index, t);
            adsr(outGain, ctx, t, dur, a, d, s, r, gain);
            mod.start(t);
            carrier.start(t);
          },
          stop(t) {
            try {
              mod.stop(t + 0.001);
              carrier.stop(t + 0.001);
            } catch {}
          },
        };
      }
      

      const engine = new Engine();
      function makePC98FM(ctx, {ratio, index, adsr, gain=0.8, pan=0}) {
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, freq, dur) {
      const car = ctx.createOscillator();
      const mod = ctx.createOscillator();
      const mg = ctx.createGain();

      car.type = 'square';
      mod.type = 'sawtooth';

      car.frequency.setValueAtTime(freq, t);
      mod.frequency.setValueAtTime(freq * ratio, t);
      mg.gain.setValueAtTime(index, t);

      mod.connect(mg).connect(car.frequency);

      const g = ctx.createGain(); g.connect(out);
      // ADSR
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(1.0, t + adsr.a);
      g.gain.linearRampToValueAtTime(adsr.s, t + adsr.a + adsr.d);
      g.gain.setValueAtTime(adsr.s, t + dur);
      g.gain.linearRampToValueAtTime(0.0001, t + dur + adsr.r);

      car.connect(g);
      car.start(t); mod.start(t);
      car.stop(t + dur + adsr.r + 0.0001);
      mod.stop(t + dur + adsr.r + 0.0001);
    },
    stop(_) {}
  };
}

// 10種類のFM音色を登録
const presets = [
  {name:'pc_bell', ratio:2,   index:40, adsr:{a:0.01,d:0.2,s:0.3,r:0.4}}, // ベル
  {name:'pc_epiano', ratio:3, index:20, adsr:{a:0.01,d:0.15,s:0.5,r:0.3}}, // エレピ
  {name:'pc_bass', ratio:1,   index:60, adsr:{a:0.005,d:0.1,s:0.7,r:0.2}}, // ベース
  {name:'pc_brass', ratio:1.5,index:25, adsr:{a:0.005,d:0.12,s:0.6,r:0.25}}, // ブラス
  {name:'pc_strings',ratio:2.5,index:15,adsr:{a:0.05,d:0.2,s:0.7,r:0.5}}, // ストリングス
  {name:'pc_lead', ratio:2,   index:35, adsr:{a:0.005,d:0.08,s:0.6,r:0.2}}, // リード
  {name:'pc_pad',  ratio:1.2, index:10, adsr:{a:0.2,d:0.3,s:0.8,r:0.8}},   // パッド
  {name:'pc_organ',ratio:4,   index:5,  adsr:{a:0.01,d:0.05,s:0.9,r:0.2}}, // オルガン
  {name:'pc_clav', ratio:2.8, index:18, adsr:{a:0.005,d:0.05,s:0.4,r:0.1}}, // クラビ
  {name:'pc_synlead',ratio:3, index:50, adsr:{a:0.005,d:0.1,s:0.5,r:0.3}}  // シンセリード
];

presets.forEach(p => {
  engine.registerInstrument(p.name, (ctx, opts={}) => makePC98FM(ctx, {...p, ...opts}));
});
engine.registerInstrument('pc', (ctx, opts={}) => {
  const {
    gain=0.9, pan=0, ratio=1.0, index=55,
    adsr={a:0.004,d:0.12,s:0.75,r:0.18,peak:1.0},
    lpCut=1800, subMix=0.2
  } = opts;

  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan });
  const lpf = ctx.createBiquadFilter();
  lpf.type = 'lowpass'; lpf.frequency.value = lpCut;
  out.connect(p).connect(lpf).connect(engine.master);

  return {
    start(t, freq, dur) {
      // キャリア
      const car = ctx.createOscillator(); car.type = 'square';
      car.frequency.setValueAtTime(freq, t);

      // モジュレーター
      const mod = ctx.createOscillator(); mod.type = 'sawtooth';
      mod.frequency.setValueAtTime(freq * ratio, t);
      const mg = ctx.createGain(); mg.gain.setValueAtTime(index, t);
      mod.connect(mg).connect(car.frequency);

      // サブオシレーター
      const sub = ctx.createOscillator(); sub.type = 'sine';
      sub.frequency.setValueAtTime(freq/2, t);
      const subGain = ctx.createGain(); subGain.gain.value = subMix;

      // 出力ゲイン＋ADSR
      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, adsr);

      car.connect(g);
      sub.connect(subGain).connect(g);

      car.start(t); mod.start(t); sub.start(t);
      const stopT = envStop.stopAt + 0.02;
      car.stop(stopT); mod.stop(stopT); sub.stop(stopT);
    },
    stop(_) {}
  };
});
   engine.registerInstrument('euro', (ctx, opts={}) => {
  const {
    gain=0.6, pan=0, unison=14, detune=800, freq=700, dur=0.3
  } = opts;

  const out = ctx.createGain();
  out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan });
  out.connect(p).connect(engine.master);

  return {
    start(t, freqIn, durIn) {
      const now = t;
      const baseFreq = freqIn || freq;
      const duration = durIn || dur;

      for (let i = 0; i < unison; i++) {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';

        const startDetune = (i - (unison - 1) / 2) * detune;
        const endDetune = (i - (unison - 1) / 80) * (detune * 0.01);

        osc.frequency.setValueAtTime(baseFreq, now);
        osc.detune.setValueAtTime(startDetune, now);
        osc.detune.linearRampToValueAtTime(endDetune, now + 0.03);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.3, now); // 各ボイスを少し抑える
        g.gain.linearRampToValueAtTime(0, now + 1);
        osc.connect(g).connect(out);

        osc.start(now);
        
        osc.stop(now + duration+1);
      }
    },
    stop(_) {}
  };
});

      engine.registerInstrument('vrcc', (ctx, opts={}) => {
  const { type='pulse', duty=0.5, vibrato=0, gain=0.8, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, freq, dur) {
      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, { a:0.005, d:0.06, s:0.7, r:0.10, peak:1.0 });

      const osc = ctx.createOscillator();
      if (type === 'saw') {
        osc.type = 'sawtooth';
      } else {
        // pulse
        const pw = createPulseWave(ctx, duty);
        osc.setPeriodicWave(pw);
      }
      osc.frequency.setValueAtTime(freq, t);

      // Vibrato (±cent)
      if (vibrato > 0) {
        const lfo = ctx.createOscillator();
        const lfoGain = ctx.createGain();
        lfo.frequency.setValueAtTime(6, t);
        lfoGain.gain.setValueAtTime(freq * (Math.pow(2, vibrato/1200) - 1), t);
        lfo.connect(lfoGain).connect(osc.frequency);
        lfo.start(t); lfo.stop(envStop.stopAt + 0.02);
      }

      osc.connect(g);
      osc.start(t);
      osc.stop(envStop.stopAt + 0.02);
    },
    stop(_) {}
  };
});
      // キックドラム
engine.registerInstrument('kick', (ctx, opts={}) => {
  const { gain=1.0, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, _, dur=0.5) {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + dur);

      const g = ctx.createGain(); g.connect(out);
      g.gain.setValueAtTime(1.0, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);

      osc.connect(g);
      osc.start(t);
      osc.stop(t + dur + 0.01);
    },
    stop(_) {}
  };
});

// スネアドラム
engine.registerInstrument('snare', (ctx, opts={}) => {
  const { gain=0.8, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, _, dur=0.2) {
      // ノイズ
      const bufferSize = ctx.sampleRate * dur;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;

      const g = ctx.createGain(); g.connect(out);
      g.gain.setValueAtTime(1.0, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);

      noise.connect(g);
      noise.start(t);
      noise.stop(t + dur + 0.01);

      // ボディ（短いトーン）
      const osc = ctx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(180, t);
      const og = ctx.createGain(); og.connect(out);
      og.gain.setValueAtTime(0.5, t);
      og.gain.exponentialRampToValueAtTime(0.001, t + dur);
      osc.connect(og);
      osc.start(t);
      osc.stop(t + dur + 0.01);
    },
    stop(_) {}
  };
});

// ハイハット
engine.registerInstrument('hihat', (ctx, opts={}) => {
  const { gain=0.5, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, _, dur=0.15) {
      const bufferSize = ctx.sampleRate * dur;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0; i<bufferSize; i++) data[i] = (Math.random()*2-1) * 0.5;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;

      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 5000;

      const g = ctx.createGain(); g.connect(out);
      g.gain.setValueAtTime(1.0, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);

      noise.connect(hp).connect(g);
      noise.start(t);
      noise.stop(t + dur + 0.01);
    },
    stop(_) {}
  };
});

engine.registerInstrument('vrcs', (ctx, opts={}) => {
  const { patch=0, gain=0.8, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  // パッチ定義（ratio/index/feedbackなどの簡易版）
  const patches = [
    { ratio:2, index:40, feedback:0.2, a:0.01, d:0.08, s:0.6, r:0.12 }, // Lead
    { ratio:3, index:25, feedback:0.1, a:0.005, d:0.06, s:0.5, r:0.10 }, // Brass
    { ratio:1.5, index:60, feedback:0.3, a:0.02, d:0.12, s:0.4, r:0.18 }, // Bell
    { ratio:1, index:20, feedback:0.05, a:0.005, d:0.05, s:0.7, r:0.10 }, // Soft
    // 以降は同様に埋めていける
  ];
  const P = patches[patch % patches.length];

  return {
    start(t, freq, dur) {
      const car = ctx.createOscillator(); car.type = 'sine';
      const mod = ctx.createOscillator(); mod.type = 'sine';
      const mg = ctx.createGain();
      const fb = ctx.createGain(); fb.gain.value = P.feedback;

      car.frequency.setValueAtTime(freq, t);
      mod.frequency.setValueAtTime(freq * P.ratio, t);
      mg.gain.setValueAtTime(P.index, t);

      // 簡易フィードバック（キャリアの出力を少し周波数へ）
      const fbGain = ctx.createGain();
      fbGain.gain.value = freq * 0.001;
      car.connect(fbGain).connect(car.frequency);

      mod.connect(mg).connect(car.frequency);
      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, { a:P.a, d:P.d, s:P.s, r:P.r, peak:1.0 });

      car.connect(g);
      mod.start(t); car.start(t);
      mod.stop(envStop.stopAt + 0.02); car.stop(envStop.stopAt + 0.02);
    },
    stop(_) {}
  };
});
engine.registerInstrument('n', (ctx, opts={}) => {
  const { gain=0.8, pan=0, table=null } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  const defaultTable = [
    0,0.4,0.8,1,0.8,0.4,0,-0.4,-0.8,-1,-0.8,-0.4,0,0.2,0.4,0.6,
    0.8,1,0.8,0.6,0.4,0.2,0,-0.2,-0.4,-0.6,-0.8,-1,-0.8,-0.6,-0.4,-0.2
  ];

  const wav = createWavetable(ctx, (table && table.length? table : defaultTable));

  return {
    start(t, freq, dur) {
      const osc = ctx.createOscillator();
      osc.setPeriodicWave(wav);
      osc.frequency.setValueAtTime(freq, t);

      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, { a:0.005, d:0.06, s:0.7, r:0.10 });
      osc.connect(g);
      osc.start(t);
      osc.stop(envStop.stopAt + 0.02);
    },
    stop(_) {}
  };
});
engine.registerInstrument('fds', (ctx, opts={}) => {
  const { gain=0.8, pan=0, table=null, modDepth=0.02, modRate=5 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  const defaultTable = Array.from({length:32}, (_,i)=> Math.sin(2*Math.PI*i/32)); // 32点サイン
  const wav = createWavetable(ctx, table ?? defaultTable);

  return {
    start(t, freq, dur) {
      const osc = ctx.createOscillator();
      osc.setPeriodicWave(wav);
      osc.frequency.setValueAtTime(freq, t);

      // FDS風モジュレーション（周波数LFO）
      const lfo = ctx.createOscillator();
      const lfoGain = ctx.createGain();
      lfo.frequency.setValueAtTime(modRate, t);
      lfoGain.gain.setValueAtTime(freq * modDepth, t);
      lfo.connect(lfoGain).connect(osc.frequency);

      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, { a:0.01, d:0.05, s:0.7, r:0.12 });

      osc.connect(g);
      lfo.start(t); osc.start(t);
      lfo.stop(envStop.stopAt + 0.02); osc.stop(envStop.stopAt + 0.02);
    },
    stop(_) {}
  };
});
      // タム (低めのトーン＋短い減衰)
engine.registerInstrument('tom', (ctx, opts={}) => {
  const { gain=0.9, pan=0, freq=120 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, _, dur=0.4) {
      const osc = ctx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, t);
      osc.frequency.exponentialRampToValueAtTime(freq/2, t + dur);

      const g = ctx.createGain(); g.connect(out);
      g.gain.setValueAtTime(1.0, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);

      osc.connect(g);
      osc.start(t);
      osc.stop(t + dur + 0.01);
    },
    stop(_) {}
  };
});

// クラップ (短いノイズを複数重ねる)
engine.registerInstrument('clap', (ctx, opts={}) => {
  const { gain=0.8, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  function noiseBurst(t, dur) {
    const bufferSize = ctx.sampleRate * dur;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;
    const src = ctx.createBufferSource();
    src.buffer = buffer;
    return src;
  }

  return {
    start(t, _, dur=0.25) {
      const delays = [0, 0.02, 0.04]; // 拍手の重なり
      delays.forEach(d => {
        const src = noiseBurst(t, dur);
        const g = ctx.createGain(); g.connect(out);
        g.gain.setValueAtTime(1.0, t+d);
        g.gain.exponentialRampToValueAtTime(0.001, t+d+dur);
        src.connect(g);
        src.start(t+d);
        src.stop(t+d+dur+0.01);
      });
    },
    stop(_) {}
  };
});

// クラッシュシンバル (長めのノイズ＋ハイパス)
engine.registerInstrument('crash', (ctx, opts={}) => {
  const { gain=0.7, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, _, dur=2.0) {
      const bufferSize = ctx.sampleRate * dur;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;

      const hp = ctx.createBiquadFilter();
      hp.type = 'highpass';
      hp.frequency.value = 4000;

      const g = ctx.createGain(); g.connect(out);
      g.gain.setValueAtTime(1.0, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + dur);

      noise.connect(hp).connect(g);
      noise.start(t);
      noise.stop(t + dur + 0.01);
    },
    stop(_) {}
  };
});

engine.registerInstrument('sunb', (ctx, opts={}) => {
  const { gain=0.8, pan=0, duty=0.5, envShape='sharp' } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);
  const pw = createPulseWave(ctx, duty);

  const shapes = {
    sharp: { a:0.002, d:0.05, s:0.6, r:0.08 },
    soft:  { a:0.01,  d:0.08, s:0.7, r:0.12 },
    stab:  { a:0.001, d:0.04, s:0.4, r:0.06 },
  };
  const E = shapes[envShape] ?? shapes.sharp;

  return {
    start(t, freq, dur) {
      const osc = ctx.createOscillator();
      osc.setPeriodicWave(pw);
      osc.frequency.setValueAtTime(freq, t);
      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, E);
      osc.connect(g);
      osc.start(t);
      osc.stop(envStop.stopAt + 0.02);
    },
    stop(_) {}
  };
});
engine.registerInstrument('mmc', (ctx, opts={}) => {
  const { gain=0.8, pan=0, duty=0.5 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);
  const pw = createPulseWave(ctx, duty);

  return {
    start(t, freq, dur) {
      const osc = ctx.createOscillator();
      osc.setPeriodicWave(pw);
      osc.frequency.setValueAtTime(freq, t);
      const g = ctx.createGain(); g.connect(out);
      const envStop = scheduleADSR(g.gain, t, dur, { a:0.003, d:0.06, s:0.65, r:0.10 });
      osc.connect(g);
      osc.start(t);
      osc.stop(envStop.stopAt + 0.02);
    },
    stop(_) {}
  };
});
engine.registerInstrument('pl', (ctx, opts={}) => {
  const { gain=0.9, pan=0 } = opts;
  const out = ctx.createGain(); out.gain.value = gain;
  const p = new StereoPannerNode(ctx, { pan }); out.connect(p).connect(engine.master);

  return {
    start(t, freq, dur) {
      const g = ctx.createGain(); g.connect(out);

      // ADSRを dur に収める
      const A = 0.01, D = 0.05, S = 0.7;
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(1.0, t + A);          // Attack
      g.gain.linearRampToValueAtTime(S, t + A + D);        // Decay
      g.gain.setValueAtTime(S, t + dur - 0.01);            // Sustain
      g.gain.linearRampToValueAtTime(0.0001, t + dur);     // Releaseをdurに収める

      // デチューンSawを2本だけ
      [0.995, 1.005].forEach(detune => {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq * detune, t);
        osc.connect(g);
        osc.start(t);
        osc.stop(t + dur); // durで止める
      });
    },
    stop(_) {}
  };
});

      
      engine.registerInstrument("square", (ctx, opts) =>
        OscInstrument(ctx, { type: "square", ...opts })
      );
      engine.registerInstrument("saw", (ctx, opts) =>
        OscInstrument(ctx, { type: "sawtooth", ...opts })
      );
      engine.registerInstrument("triangle", (ctx, opts) =>
        OscInstrument(ctx, { type: "triangle", ...opts })
      );
      engine.registerInstrument("sine", (ctx, opts) =>
        OscInstrument(ctx, { type: "sine", ...opts })
      );
      engine.registerInstrument("noise", (ctx, opts) =>
        NoiseInstrument(ctx, opts)
      );
      engine.registerInstrument("fm", (ctx, opts) => FMInstrument(ctx, opts));

      // ----------------------------
      // Multi-track assembly
      // ----------------------------
      function parseAllTracks(text) {
        const lines = text
          .split("\n")
          .map((s) => s.trim())
          .filter((s) => s.length > 0);
        const timelines = [];
        for (const line of lines) {
          const ast = parseTrack(line);
          const tl = buildTimeline(ast);
          timelines.push(tl);
        }
        return timelines;
      }

      // ----------------------------
      // UI wiring
      // ----------------------------
      const input = document.getElementById("mml");
      const playBtn = document.getElementById("play");
      const stopBtn = document.getElementById("stop");
      const master = document.getElementById("master");
      const wav = document.getElementById("wav");

      master.addEventListener("input", () =>
        engine.setMaster(parseFloat(master.value))
      );

      playBtn.addEventListener("click", () => {
        try {
          const tracks = parseAllTracks(input.value);
          engine.play(tracks);
        } catch (e) {
          alert("Parse/Play error: " + e.message);
        }
      });
      stopBtn.addEventListener(
        "click",
        () => engine.ensure() && engine.stopAll()
      );
// AudioBuffer → WAV Blob 変換
function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const view = new DataView(new ArrayBuffer(length));
  let offset = 0;

  function writeString(s) {
    for (let i = 0; i < s.length; i++) view.setUint8(offset++, s.charCodeAt(i));
  }

  // RIFFヘッダ
  writeString('RIFF');
  view.setUint32(offset, length - 8, true); offset += 4;
  writeString('WAVE');
  writeString('fmt ');
  view.setUint32(offset, 16, true); offset += 4;
  view.setUint16(offset, 1, true); offset += 2; // PCM
  view.setUint16(offset, numOfChan, true); offset += 2;
  view.setUint32(offset, buffer.sampleRate, true); offset += 4;
  view.setUint32(offset, buffer.sampleRate * numOfChan * 2, true); offset += 4;
  view.setUint16(offset, numOfChan * 2, true); offset += 2;
  view.setUint16(offset, 16, true); offset += 2;
  writeString('data');
  view.setUint32(offset, length - 44, true); offset += 4;

  // PCMデータ
  for (let i = 0; i < buffer.length; i++) {
    for (let ch = 0; ch < numOfChan; ch++) {
      let sample = buffer.getChannelData(ch)[i];
      sample = Math.max(-1, Math.min(1, sample));
      view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
      offset += 2;
    }
  }
  return new Blob([view.buffer], { type: 'audio/wav' });
}

// MMLをオフラインでレンダリングしてWAV保存
async function exportMMLtoWav(mmlText, durationSec=10) {
  const sampleRate = 44100;
  const offline = new OfflineAudioContext(2, sampleRate * durationSec, sampleRate);

  // ここで通常の engine.play と同じ処理を offline に流し込む
  const tracks = parseAllTracks(mmlText);
  
  engine.ctx = offline;
  engine.master = offline.destination;
  engine.play(tracks);

  const rendered = await offline.startRendering();
  const wavBlob = audioBufferToWav(rendered);

  // ダウンロード
  const url = URL.createObjectURL(wavBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'output.wav';
  a.click();
  URL.revokeObjectURL(url);
}
// テキストエリアのMMLをWAV保存
document.getElementById('wav').addEventListener('click', () => {
  const mml = document.getElementById('mml').value;
  exportMMLtoWav(mml, 120); // 20秒分レンダリング
});

      // ----------------------------
      // Example default MML
      // ----------------------------
      input.value = `@square t140 o4 l8 v110 p-20 c d e f g a b > c4.
@saw    t140 o3 l8 v96  p20  [c e g]2 > [c e g]2 < [b- d f]2 r4
@fm     t140 o2 l16 v90 p0   [c c& c]4 d-8. e8 f+8 g4 r2`;
    </script>
  </body>
</html>
